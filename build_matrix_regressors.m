function x = build_matrix_regressors(behav,ephys)

% x = build_regressor_matrix(behav)
%
% This function generates the matrix of regressors used to compute
% the pulse-evoked and other kernels describing neural activity.
%
% GLOBAL VARIABLES: this function assumes the definition of global
% variable "glm" that defines a series of hyperparameters, computed
% by compute_glm_variables
%
% PARAMETERS: structure "behav" containing all information about
% the stimulus and the rat's behavior for one session of Marino
% context-dependent decision making task (protocol TaskSwitch4 or
% TaskSwitch6). This structure is generated by loadcell_rat (for
% rat data) or loadcell_unit (for RNN data)
%
% RETURNS: regressor matrix "x". Rows indicate time points across
% trials, columns indicate regressors


global glm

edges=(glm.xmi-glm.res/2):glm.res:(glm.xma+glm.res/2);

glm.ntime=length(edges)-1;


indiz=find(glm.centers2>glm.limi(2));
behav.stim(:,indiz,:)=0;

tic
for i = 1:behav.nTrials
    
    
    
    if(behav.task(i)=='d')
        
        
        dir_info_dir=squeeze(behav.stim(i,:,1));
        
        freq_info_dir=squeeze(behav.stim(i,:,2));
        
        dir_info_freq=zeros(1,glm.ntime);
        
        freq_info_freq=zeros(1,glm.ntime);
        
        
        Xco{i}=eye(glm.ntime);
        
        
    elseif(behav.task(i)=='f')
        
        
        dir_info_dir=zeros(1,glm.ntime);
        
        freq_info_dir=zeros(1,glm.ntime);
        
        dir_info_freq=squeeze(behav.stim(i,:,1));
        
        freq_info_freq=squeeze(behav.stim(i,:,2));
        
        
        Xco{i}=-eye(glm.ntime);
        
        
    end
    
    
    
    if(behav.choice(i)==1)
        Xch{i}=eye(glm.ntime);
    else   %(choice(i)==0)
        Xch{i}=-eye(glm.ntime);
    end
    
    Xt{i}=eye(glm.ntime);
    
    
    if(isfield(glm,'no_pulse') && glm.no_pulse==1)
        
        
        if(behav.task(i)=='d')
            
            
            
            Xdd{i}=behav.gdir(i)*eye(glm.ntime);
            
            Xfd{i}=behav.gfreq(i)*eye(glm.ntime);
            
            Xdf{i}=zeros(glm.ntime,glm.ntime);
            
            Xff{i}=zeros(glm.ntime,glm.ntime);
            
            
        elseif(behav.task(i)=='f')
            
            
            Xdf{i}=behav.gdir(i)*eye(glm.ntime);
            
            Xff{i}=behav.gfreq(i)*eye(glm.ntime);
            
            Xdd{i}=zeros(glm.ntime,glm.ntime);
            
            Xfd{i}=zeros(glm.ntime,glm.ntime);
            
            
        end
        
        
    else
        
        Xdd{i} = hankel([zeros(glm.ntfilt-1,1);dir_info_dir(1:end-glm.ntfilt+1)'],...
            dir_info_dir(end-glm.ntfilt+1:end)');
        Xfd{i} = hankel([zeros(glm.ntfilt-1,1);freq_info_dir(1:end-glm.ntfilt+1)'],...
            freq_info_dir(end-glm.ntfilt+1:end)');
        
        Xdf{i} = hankel([zeros(glm.ntfilt-1,1);dir_info_freq(1:end-glm.ntfilt+1)'],...
            dir_info_freq(end-glm.ntfilt+1:end)');
        Xff{i} = hankel([zeros(glm.ntfilt-1,1);freq_info_freq(1:end-glm.ntfilt+1)'],...
            freq_info_freq(end-glm.ntfilt+1:end)');
        
    end
    
end


if(glm.include_choice)
    
    
    
    
    if(isfield(glm,'no_pulse') && glm.no_pulse==1)
        
        glm.ngrps=[glm.ntime,glm.ntime,glm.ntime,glm.ntime,...
            glm.ntime,glm.ntime,glm.ntime];
        
    else
        
        glm.ngrps=[glm.ntfilt,glm.ntfilt,glm.ntfilt,glm.ntfilt,...
            glm.ntime,glm.ntime,glm.ntime];
        
    end
    
    
    glm.grpnames={'dd','fd','df','ff','time','context','choice'};
    
    %we are using same regression coefficient for all groups
    glm.lam=glm.lambda1*ones(1,7);
    
    z=2;
    for i=1:length(glm.ngrps)
        glm.indi{i}=z:z+glm.ngrps(i)-1;
        z=z+glm.ngrps(i);
    end
    
    
    if(isfield(glm,'no_pulse') && glm.no_pulse==1)
        
        x=nan(glm.ntime*behav.nTrials,1+glm.ntime*7);
    else
        x=nan(glm.ntime*behav.nTrials,1+glm.ntfilt*4+glm.ntime*3);
        
    end
    
    for j=1:behav.nTrials
        indi=(j-1)*glm.ntime+1:j*glm.ntime;
        x(indi,:)=[ones(glm.ntime,1) Xdd{j} Xfd{j} Xdf{j} Xff{j} Xt{j} Xco{j} Xch{j}];
    end
    
    
    
    
    if(~(isfield(glm,'no_pulse') && glm.no_pulse==1))
        
        inda=2:glm.ntfilt*4+1;
        indb=glm.ntfilt*4+2:glm.ntfilt*4+glm.ntime*3+1;
        
        n1=norm(x(:,inda));
        n2=norm(x(:,indb));
        
        
        x(:,inda)=x(:,inda)*n2/n1;
        
    end
    
else
    
    
    
    if(isfield(glm,'no_pulse') && glm.no_pulse==1)
        
        
        glm.ngrps=[glm.ntime,glm.ntime,glm.ntime,glm.ntime,...
            glm.ntime,glm.ntime];
    else
        
        
        glm.ngrps=[glm.ntfilt,glm.ntfilt,glm.ntfilt,glm.ntfilt,...
            glm.ntime,glm.ntime];
        
    end
    
    
    glm.grpnames={'dd','fd','df','ff','time','context'};
    
    %we are using same regression coefficient for all groups
    glm.lam=glm.lambda1*ones(1,6);
    
    z=2;
    for i=1:length(glm.ngrps)
        glm.indi{i}=z:z+glm.ngrps(i)-1;
        z=z+glm.ngrps(i);
    end
    
    
    
    
    if(isfield(glm,'no_pulse') && glm.no_pulse==1)
        
        x=nan(glm.ntime*behav.nTrials,1+glm.ntime*6);
    else
        
        x=nan(glm.ntime*behav.nTrials,1+glm.ntfilt*4+glm.ntime*2);
        
    end
    for j=1:behav.nTrials
        indi=(j-1)*glm.ntime+1:j*glm.ntime;
        x(indi,:)=[ones(glm.ntime,1) Xdd{j} Xfd{j} Xdf{j} Xff{j} Xt{j} Xco{j}];
    end
    
    if(~(isfield(glm,'no_pulse') && glm.no_pulse==1))
        
        
        inda=2:glm.ntfilt*4+1;
        indb=glm.ntfilt*4+2:glm.ntfilt*4+glm.ntime*2+1;
        
        n1=norm(x(:,inda));
        n2=norm(x(:,indb));
        
        x(:,inda)=x(:,inda)*n2/n1;
    end
    
end


if(glm.include_history)
    
    if(size(ephys.rrr4,3)==1) %%% only one neuron
        
        glm.n_neur=1;
        
        y=ephys.rrr4(:);
        
        % Build spike-history design matrix
        paddedSps = [zeros(glm.nthist,1); y(1:end-1)];
        % SUPER important: note that this doesn't include the spike count for the
        % bin we're predicting? The spike train is shifted by one bin (back in
        % time) relative to the stimulus design matrix
        Xsp = hankel(paddedSps(1:end-glm.nthist+1), paddedSps(end-glm.nthist+1:end));
        
        
        % Combine these into a single design matrix
        x = [x,Xsp];
        
        
        
        glm.ngrps=[glm.ngrps,glm.nthist];
        glm.grpnames=[glm.grpnames 'history'];
        glm.lam=[glm.lam, glm.lam(1)/(2^14)];
        
        
    else  %%% many neurons
        
        glm.n_neur=size(ephys.rrr4,1);
        
        for iii=1:glm.n_neur
            
            rrr4_use=squeeze(ephys.rrr4(iii,:,:));
            
            y=rrr4_use(:);
            
            % Build spike-history design matrix
            paddedSps = [zeros(glm.nthist,1); y(1:end-1)];
            % SUPER important: note that this doesn't include the spike count for the
            % bin we're predicting? The spike train is shifted by one bin (back in
            % time) relative to the stimulus design matrix
            Xsp = hankel(paddedSps(1:end-glm.nthist+1), paddedSps(end-glm.nthist+1:end));
            
            % Combine these into a single design matrix
            x = [x,Xsp];
            
            glm.ngrps=[glm.ngrps,glm.nthist];
            glm.grpnames=[glm.grpnames 'history'];
            glm.lam=[glm.lam, glm.lam(1)/(2^24)];
            
            
        end
        
        
    end
    
    
    if(~(isfield(glm,'no_pulse') && glm.no_pulse==1))
        
        
        if(glm.include_choice)
            
            n3=norm(x(:,glm.ntfilt*4+glm.ntime*3+2:end));
            x(:,glm.ntfilt*4+glm.ntime*3+2:end)=x(:,glm.ntfilt*4+glm.ntime*3+2:end)*n2/n3;
            
        else
            
            n3=norm(x(:,glm.ntfilt*4+glm.ntime*2+2:end));
            x(:,glm.ntfilt*4+glm.ntime*2+2:end)=x(:,glm.ntfilt*4+glm.ntime*2+2:end)*n2/n3;
        end
        
    end
    
end



